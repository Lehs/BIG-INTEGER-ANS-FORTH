\ unsigned natural numbers of dynamical length in 32 bit ANS Forth
\ 2015 ver 2.0
\ started by Lars-Erik Svahn, Sweden
\ I appreciate enhancements and other feedback
\ lehs@hotmail.se 
base @ hex
\ miscellanous

 : 0! 0 swap ! ;
 : 1+! 1 swap +! ;
 : u2/ 1 rshift ;
 : u/ 0 swap um/mod nip ;
 : umod 0 swap um/mod drop ;
 : cell- cell - ;
 : rdrop r> drop ;

: d256*  \ ud -- 256ud
  over 8 lshift rot 0FF000000 and 018 rshift
  rot 8 lshift or ;

: sqrtf \ m -- n	floor
  dup 4 u< 
  if dup 
     if drop 1
     then exit
  then dup 1- >r u2/	\ start value
  begin r@ over u/	\ Newton-Ralphson
     over + u2/
     tuck u> 0=
  until rdrop ;

: sqrtc \ m -- n	ceiling
  1- sqrtf 1+ ;

0400 constant 1k
cell negate constant -cell

\ extra stacks for singel numbers

1k allocate throw dup value xs dup ! 

: >xs ( n -- )  cell xs +! xs @ ! ;
: xs> ( -- n )  xs @ @ -cell xs +! ;
: xs@ ( -- n )  xs @ @ ;
: xs! ( n -- )  xs @ ! ;
: xs+! ( n -- )  xs @ +! ; 
: xsdrop ( -- )  -cell xs +! ; 
: xsdrops ( n -- )  cells negate xs +! ;
: xsdepth ( -- #bytes )  xs @ xs - 2/ 2/ ;

1k allocate throw dup value ys dup ! 

: >ys ( n -- )  cell ys +! ys @ ! ;
: ys> ( -- n )  ys @ @ -cell ys +! ;
: ys@ ( -- n )  ys @ @ ;
: ys! ( n -- )  ys @ ! ;
: ys+! ( n -- )  ys @ +! ; 
: ysdrop ( -- )  -cell ys +! ; 
: ysdrops ( n -- )  cells negate ys +! ;
: ysdepth ( -- n )  ys @ ys - 2/ 2/ ;

1k allocate throw dup value zs dup ! 

: >zs ( n -- )  cell zs +! zs @ ! ;
: zs> ( -- n )  zs @ @ -cell zs +! ;
: zs@ ( -- n )  zs @ @ ;
: zs! ( n -- )  zs @ ! ;
: zs+! ( n -- )  zs @ +! ; 
: zsdrop ( -- )  -cell zs +! ; 
: zsdrops ( n -- )  cells negate zs +! ;
: zsdepth ( -- n )  zs @ zs - 2/ 2/ ;
: drop-all ( -- )  xsdrop ysdrop zsdrop ;

: log~ \ n -- #binary digits 
  0 >xs begin 1 xs+! u2/ ?dup 0= until xs> ;

   8 cell * constant bits
    bits 1- constant bits-1
bits-1 log~ constant lbits

: 2/mod \ n -- r q
  dup 1 and swap u2/ ;

: 4/mod \ n -- r q
  dup 3 and swap 2 rshift ;

: 8/mod \ n -- r q
  dup 7 and swap 3 rshift ;

: bits/mod \ n -- r q
  dup bits-1 and swap lbits rshift ;

: 256/mod \ n -- r q
  dup 0FF and swap 8 rshift ;

\ pseudo random numbers

  variable rnd 

: reset_seed 0ABCDEF1 rnd ! ; reset_seed

: rand \ -- u
  rnd @ 08088405 * 1+ dup rnd ! ;

: random \ u1 -- u2
  rand um* nip ;


\ big integers based on cell "digits", ie the base is 2^32

\ main stack
\ pointer stack in high mem towards low mem
\ array stack in low mem towards high mem

0A000 constant maxv
maxv cell + allocate throw aligned constant v$0
v$0 maxv + constant b0
variable bvp

\ extra stack
08000 constant maxx
maxx cell + allocate throw aligned constant x$0
x$0 maxx + constant x0
variable xp

\ extra pad
02000 dup allocate throw constant pad1 
pad1 + cell - constant pad2

: rez \ a n -- a' n'	delete leading zero ascii 48 in string
  dup 1 =
  if exit
  then over c@ 030 =
  if 1- swap 1+ swap recurse
  then ;

: asc>  0F and ;		\ ascii number to binary number
: >asc  030 or ;		\ reverse
: vst!  b0 cell - bvp ! v$0 bvp @ ! ;

vst! 	\ initialize stack fÃ¶r dynamical numbers

: nextfree ( -- a )  bvp @ @ ;
: first ( -- a )  bvp @ cell + @ ;		\ big on tos
: second ( -- a )  bvp @ 2 cells + @ ;		\ big on second
: third ( -- a )  bvp @ 3 cells + @ ;		\ big on third
: vp+ ( -- )  -cell bvp +! ;			\ stack pointer

: tov \ ad --		ad of number array to stack
  vp+ bvp @ ! ;

: bempty ( -- f )  nextfree v$0 = ;
: len1 ( -- n )  nextfree first - ;		\ get length to first
: len2 ( -- n )  first second - ;
: len3 ( -- n )  second third - ;
: top$ ( -- a n )  first len1 ;
: sec$ ( -- a n )  second len2 ;
: thi$ ( -- a n )  third len3 ;

: vdigit \ n --		put single "digit" on stack
  nextfree tuck ! cell+ tov ;

: bsconstant \ n -- 
  create , does> @ vdigit ;
  
: dvdigit \ ud -- 	put double "digit" number on stack
  swap nextfree dup >r 2! 2 cells r> + tov ;

: bdconstant \ d --
  create , , does> 2@ dvdigit ;

: vpush \ a n --	put string on stack
  rez >xs nextfree xs@ over + tov xs> cmove ;

: bpush \ a n --	put any number array on stack
  nextfree over aligned		\ a n nxt na
  2dup + cell - 0!		\ a n nxt na 
  over + tov			\ a n nxt
  swap cmove ;			\ 

: bpusha \ a n --	put aligned number array on stack
  nextfree 2>r 2r@ swap cmove
  2r> + tov ;

: bdupall \ v -- v u	allocate array of same size
  nextfree len1 + tov ;

: bdrop  cell bvp +! ;
: bdup  top$ bpusha ;
: vdup  top$ vpush ;
: bover  sec$ bpusha ;
: boover  thi$ bpusha ;

: bvariable \ n -- 
  create allocate throw cell , , does> ; 
   
: b! \ v -- | ad --
  dup cell+ @ first nextfree over - rot swap >r r@ cmove
  r> swap ! bdrop ;

: b@ \ -- v | ad --
  2@ bpusha ;

: xst!  x0 cell - xp ! x$0 xp @ ! ; xst!	\ reset extra stack
: xp+ ( -- )  -cell xp +! ;
: tox ( a -- )  xp+ xp @ ! ; 
: xnext ( -- ad )  xp @ @ ;
: xfirst ( -- ad )  xp @ cell+ @ ;
: xsecond ( -- ad )  xp @ 2 cells + @ ;
: xthird ( -- ad )  xp @ 3 cells + @ ;
: xlen ( -- n )  xnext xfirst - ;
: xpush ( a n -- ) rez >xs xnext xs@ over + tox xs> cmove ;

: bxpush ( a n -- ) >xs xnext xs@ over + tox xs> cmove ; 
: xdrop  cell xp +! ;
: xempty ( -- f )  xnext x$0 = ;

: >bx ( v -- )  top$ bxpush bdrop ;
: bx! ( v -- v )  top$ bxpush ;
: bx  ( -- v )  xfirst xnext over - bpusha ;
: bx> ( -- v )  bx xdrop ;

: by  \ -- v	      the second value on x-stack
  xsecond xfirst over - bpusha ;

: bz  ( -- v )  xthird xsecond over - bpusha ;
: v>x ( v -- )  top$ bdrop xpush ;
: vx  ( -- v )  xfirst xnext over - vpush ;
: vx> ( -- v )  vx xdrop ;

: vy  \ -- v
  xsecond xfirst over - vpush ;

: bnip  >bx bdrop bx> ;
: bswap  >bx >bx by bx> xdrop ;
: vswap  v>x v>x vy vx> xdrop ;
: brot  >bx bswap bx> bswap ;
: btuck  bswap bover ;
: b2swap brot >bx brot bx> ;
: b2dup bover bover ;
: b2drop bdrop bdrop ;
: b3dup boover boover boover ;

: reztop  top$ xpush bdrop bx> ;       	\ clean leading asczeros
: vzero  [char] 0 nextfree tuck c! 1+ tov ;
: bzero 0 vdigit ;			\ small bigintegers
: bone  1 vdigit ;
: btwo  2 vdigit ;
: bthree 3 vdigit ;
: bten  0A vdigit ;

: byte1@ \ v -- v | -- b  get least significant byte of tos
  first c@ ;

: byte2@ \ v -- v | -- b  least sign byte on second number
  second c@ ;

: <vtop  \ delete unwanted leading asc zeros
  begin len1 2 <
     if exit then nextfree 1- c@ 0=	
  while -1 bvp @ +! 
  repeat ;

: <top  \ delete unwanted leading zeros
  begin len1 cell > 0=
     if nextfree 0! cell len1 - bvp @ +! exit
     then nextfree cell - @ 0= 		
  while -cell bvp @ +! 
  repeat nextfree 0! cell len1 3 and - 3 and bvp @ +! ;

: vr< \ u v -- u v | -- f	compare numbers as asc strings
  reztop <vtop vswap reztop <vtop vswap
  len2 len1 2dup <
  if 2drop true exit
  then dup >zs > 
  if zsdrop false exit
  then first nextfree 1- 
  do i zs@ - c@ i c@ 2dup = 0=
     if zsdrop < 
        if true 
        else false 
        then unloop exit
     then 2drop -1
  +loop zsdrop false ;

: vr= \ u v -- u v | -- f	
  vr< 
  if false exit 
  then vswap vr< 
  if vswap false exit 
  then vswap true ;

: v2/  \ v -- v/2
\ divide asc number by 2
  nextfree first >xs 0 >ys
  begin xs@ c@ over xs@ >
  while asc> 2/mod ys> + >asc xs@ c!
     negate 5 and >ys 1 xs+!
  repeat reztop <vtop 2drop xsdrop ysdrop ;

: v>byte \ u -- v | -- f b
\ divide asc-string by 256 leaving rest b. f true if v=0
  xsdepth false >ys 9 1
  do nextfree 1- c@ 1 and >xs v2/ vzero vr= bdrop
     if true ys! leave then
  loop xsdepth swap - 0 tuck
  do 2* xs> + loop ys> swap ; 

: nth ( n -- b/0 )  1+ bvp @ swap cells + 
  dup b0 = 
  if drop 0 
  else @ 
  then ; 

: len# \ n -- m 
  dup nth swap 1- nth ?dup
  if swap 
  else v$0 swap 
  then - ; 

: bdepth \ -- n 
  040 0					\ depth of stack
  do i nth 0= if i leave then loop ; 

: v>b  \ convert asc-number to digital bignumber
  pad 1k 2dup + pad
  do v>byte i c!
     if drop i 1+ 0! i pad - 1+ cell+ leave then
  loop bdrop bpush <top ; 

: s>b \ -- v | n --	convert single to big
  0 <# #s #> vpush v>b ;

: b>s  \ u -- | -- n	conv big to single
  first @ bdrop ;

: d>b \ -- v | d --
  <# #s #> vpush v>b ;

: b>d  \ u -- | -- d
  top$ 5 < 
  if @ 0 
  else 2@ swap 
  then bdrop ;

: v  bl parse vpush ; 		\ 'v 12345' put asc numb on tos
: b  v v>b ;			\ put bigint on tos 
: cl vst! xst! ;		\ clear stacks

: .v  cr bdepth ?dup		\ print asc numb stack
  if 0 do i nth i len# type cr loop then ;

: .bytes cr bdepth ?dup		\ print byte string stack
  if 0 do i nth i len# 0
          do i over + c@ base @ >xs
             hex 0 <# # # #> type space xs> base !
          loop drop cr
       loop
  then ;

: b+_s>=f \ u v -- u+v		u >= v
  len2 nextfree over len1 - dup bvp @ +! erase
  0 >xs nextfree first 
  do i over - @ i @ 0 tuck d+ xs> 0 d+ >xs i ! cell
  +loop drop xs> ?dup 
  if nextfree cell bvp @ +! ! 
  then ;

: b+ \ u v -- u+v		adding bigint
  len2 len1 < 0=
  if b+_s>=f
  else bswap b+_s>=f 
  then bnip ;

: br< \ u v -- u v | -- f	bigstack remain less
  len2 len1 2dup u<
  if 2drop true exit
  then dup pad1 ! u>
  if false exit
  then first >xs second >ys 0 >zs 0 pad1 @ cell -
  do ys@ i + @ xs@ i + @ 2dup = 0=
     if drop-all u< 
        if true 
        else false 
        then unloop exit
     then 2drop -cell
  +loop drop-all false ;

: b< \ u v -- | --f		bigstack less
  br< bdrop bdrop ;

: br= \ u v -- u v | -- f
  br< if false exit then
  bswap br< if bswap false exit then bswap true ;

: b= \ u v -- | --f
  br= bdrop bdrop ;

: br0= \ v -- v | -- f
  len1 cell - first @ or 0= ;

: b0= \ v -- | -- f
  br0= bdrop ;

: gtx? \ v -- v | -- f		greater than x-value?
  len1 xlen 2dup <
  if 2drop false exit then >
  if true exit then false 0 xlen cell -
  do first i + @ xfirst i + @ 2dup <
     if 2drop leave then >
     if 0= leave then -cell
  +loop ;

: +x>=y? \ v -- | -- f		add v to bx and compare with y
  bx> b+ bx> br< >bx >bx 0=
  dup if xdrop xdrop then ;	\ 2 xdrop when equal or greater

: b~ \ u v -- |u-v| | -- f      f is minus sign		erroneous!!
  br< if bswap true else false then >zs
  first >xs second >ys false >zs
  len1 0
  do ys@ i + @ zs@ + xs@ i + @ 2dup u< zs! zs@
     if 1 swap 0 d- drop else - then ys@ i + ! cell
  +loop len2 len1
  do ys@ i + @ dup 0= xs! xs@ zs@ and
     if drop -1 
     else zs@ + 0 zs! 
     then ys@ i + ! zs@ 0= 
     if leave then cell
  +loop drop-all zs> bdrop <top ;

: b- \ u v -- u-v
  >bx >bx bx by
  b~ if cr ." negative big!" cr 10 throw then 
  xdrop xdrop ; 

: |b-| \ u v -- |u-v|
  b~ drop ;

: bsl \ n i -- n1 n0	      big shift left, n < 2^bits
  2dup bits swap - rshift -rot lshift ;

: blshift  \ v -- u | n -- 		big shift left
  bits/mod over 0= 
  if nip first dup rot cells 
     dup >xs + len1 cmove> 
     xs@ bvp @ +! first xs> erase exit
  then cells >ys				    \ i  y=4[n/32]
  ys@ first dup >xs + 			            \ i f+4[n/32]  x=first
  xs@ over len1 dup >zs cmove>		            \ i f+4[n/32]  z=len1
  xs@ ys@ erase
  zs> over + dup xs! swap 0 >zs		            \ i f+4[n/32]+len1 f+4[n/32]
  ?do i @ over bsl zs> or i ! >zs cell 
  +loop zs@ xs@ ! 
  xs@ cell+ bvp @ ! 
  drop drop-all <top ;

: brshift \ v -- u | n -- 
  8/mod >ys >xs 
  nextfree 0! nextfree first
  do ys@ i + @ 0FFFF and 
     xs@ rshift dup 0FF and i c! drop
  loop nextfree ys@ - ys> erase
  <top xsdrop ;

: b1and \ v -- v s
  first @ 1 and vdigit ;

: beven \ v -- v | -- f
  first @ 1 and 0= ;

: bodd \ v -- v | -- f
  beven 0= ;

: b1or \ v -- v'
  first @ 1 or first ! ;

: b2/mod \ v -- r k 
  b1and bswap 1 brshift ;

: msb@ \ v -- v | -- c
  nextfree cell- nextfree 1-
  do i c@ ?dup 
     if leave then -1 
  +loop ;

: msb@2 \ u v -- u v | -- c
  first cell- first 1-
  do i c@ ?dup 
     if leave then -1 
  +loop ;

: z# \ v -- v | -- n
  0 >xs nextfree
  begin 1- dup c@ 0=
  while 1 xs+! 
  repeat drop xs> ;

: z#2 \ u v -- u v | -- n
  0 >xs first
  begin 1- dup c@ 0=
  while 1 xs+! 
  repeat drop xs> ;

: blog~ \ v -- v | -- n		8(len-1)+log(byte0)+1
  len1 z# - 1- 3 lshift msb@ log~ + ;

: blog~2 \ u v -- u v | -- n 
  len2 z#2 - 1- 3 lshift msb@2 log~ + ;

: blog \ v -- | -- n	 integer part of 2-logarithm
  blog~ 1- bdrop ;

: b1+ bone b+ ;
: b1- bone b- ;
: b2+ btwo b+ ;

: b2* \ v -- 2v
  1 blshift ;

: b2/ \ v -- v/2
  1 brshift ;

: b256* \ v -- 256v
  top$ over 1+ swap cmove>
  bvp @ 1+! 0 first c! ;

: last!> \ n --
  nextfree cell - ! cell bvp @ +! ;

: cell*x \ -- n*v ; x: v -- v | n --
  bzero 0 >xs xnext xfirst 
  do dup i @ um* xs> 0 d+ >xs last!> cell 
  +loop xs> nextfree cell - ! drop <top ;

: bs* \ v -- n*v | n --
  >bx cell*x xdrop ;

: bdups* \ v -- v n*v | n -- 
  bzero 0 >xs first second 
  do dup i @ um* xs> 0 d+ >xs last!> cell 
  +loop xs> nextfree cell - ! drop <top ; 

: 32bleft \ v -- w
  top$ over cell+ swap cmove>
  cell bvp @ +! 0 first ! ;

: b* \ u v -- u*v
  len1 len2 < if bswap then
  >bx bzero second first cell - 
  do 32bleft i @ cell*x b+ -cell 
  +loop bnip xdrop <top ;

: bs/mod \ v -- q | n -- r  	v=nq+r 
  >xs bdupall nextfree cell - 0!
  0 0 len1 cell -
  do i second + @ swap xs@ um/mod i first + ! -cell
  +loop <top xsdrop bnip ;

: b>v$ \ b -- b | -- a n
  pad2 pad1 ! bdup 0A 
  begin dup bs/mod >asc pad1 @ c! 
     -1 pad1 +! br0= 
  until drop bdrop 1 pad1 +! 
  pad1 @ pad2 over - 1+ ;

: b>v  \ b -- b v
  b>v$ vpush ;

: bdec# ( b -- b | -- n )  b>v$ nip ;

: br. \ b -- b
  b>v$ type space ;

: b. \ b --
  br. bdrop ;

: .b  bempty 0=
  if cr br. >bx recurse bx> then ;

: .x  xempty 0=
  if bx> cr br. recurse >bx then ;
  
: brandom \ -- u | n --		      n is the maximal number of decimal digits in u
  bzero 0 
  do bten b* 10 random s>b b+ 
  loop ;

\ 2^sxn+1=2*2^sxn-[2^sxn]^2*n/2^[2s] 
\ q=t*x/2^[2n]
: b/ \ u v -- q 				Newton-Ralphson on y=2^s/x-A
  br< if bdrop bdrop bzero exit then
  len1 cell > 0= if b>s bs/mod drop exit then
  blog~ >xs >bx bdup blog~ 2/ 6 + >ys 
  ys@ 2* xs> - dup >xs bone blshift xs>
  if 6 bs* 5 bs/mod drop then 0F 0				\ start value
  do bdup b2* bover bdup b* bx b* 
     ys@ 2* brshift b- br= bnip 
     if leave then
  loop b* ys> 2* brshift 
  begin bover bover bx b* b< 
  while b1- 
  repeat 
  begin bover bover bx b* bx b+ b< 0= 
  while b1+ 
  repeat bnip xdrop ; \ t-nq>n <=> t>n+nq

\ Barrett reduction 

variable foo
1k bvariable bar
1k bvariable den

: barmod \ w -- v		v= w mod den, w < den^2
  bdup bar b@ br< 
  if bdrop bdrop exit 
  then b* foo @ brshift      \ w q
  den b@ b* b-               \ r
  den b@ br<
  if bdrop 
  else b- 
  then ;

: >bar \ u -- 
  blog~ 2* dup foo !              \ foo = 2k
  bone blshift bover b/ bar b!    \ bar = 2^foo/u
  den b! ;                        \ bx = u

: b** \ b a -- b^a
  first @ 0= 
  if bdrop bdrop bone exit 
  then >bx bzero >bx bone
  begin bover b*
     bone +x>=y?
  until bnip ;
  
: bs** \ b -- b^n | n -- 
  ?dup 0= if bdrop bone exit then bone 0
  do bover b*
  loop bnip ;

: bmod \ w u -- r
  bover bover b/ b* b- ;
  
: b/mod \ w u -- r q
  bover bover b/ 
  bdup >bx b* b- bx> ;

: qwerty \ u v -- s t		binary split
  bover bover b+ 1 brshift bdup btwo b** bx br<
  if bdrop bdrop brot bdrop bswap
  else bdrop bdrop bnip
  then ; 

: bsqrtx \ u -- v | x: -- u
  >bx bx blog~ u2/ brshift b1+
  begin bdup bx bover b/ b+ b1+ b2/
    bswap bover |b-| bone b<  
  until ;

: bsqrt~ \ w -- u v		u=v-1 v=ceil
  bsqrtx bdup b1- bswap b1+ qwerty xdrop ;

: bsqrtf \ w -- v
  br0= if exit then
  blog~ u2/ bone blshift 10 0
  do bover bover b/ br= b+ b2/ 
     if leave then
  loop bdup bdup b* brot bswap br< bdrop bdrop
  if b1- then ;

: bsqrtc \ w -- v
  b1- bsqrtf b1+ ;

: bfaculty  \ v -- v!
  >bx bzero bone
  begin bswap b1+ gtx? bswap 0=
  while bover b*
  repeat bnip xdrop ;
  
: bsfaculty \ -- n! | n --
  1+ bone 2 do i bs* loop ;

: bgcd \ v u -- w	greatest common divisor
  br< if bswap then
  begin btuck bmod br0=
  until bdrop ;

: gcd \ m n -- d
  2dup u< if swap then
  begin tuck 0 swap um/mod drop dup 0=
  until drop ;

: blcm \ v u -- w	least common multiple
  bover bover b* brot brot bgcd b/ ;

\ the square-and-multiply-algorithm with Barrett reduction 
: b**mod \ u v m -- u^v mod m
  >bar blog~ bswap >bx bone 0        \ 
  do i bits/mod cells second + @     \ 
     1 rot lshift and                \ 
     if bx b* barmod                 \ 
     then bx bx> b* barmod >bx       \ 
  loop bnip xdrop ; 

\ rabin-miller strong pseudoprime test

: rs \ u -- s | -- r
  b1- nextfree first 0 >xs
  do i @ 
     if i >ys leave 
     then 1 xs+! cell
  +loop ys> @ bits 0
  do dup 1 and 
     if i leave 
     then u2/
  loop nip xs> lbits lshift +
  dup brshift ;

: xsi \ u -- v
  len1 bdrop cell = 
  if btwo exit 
  then 0100 random 3 or vdigit ;

: digit= \ u -- u | n -- f
  len1 cell > 
  if drop false exit 
  then first @ = ;

: pseudo1 \ xsi s m -- | -- f
  b**mod 1 digit= bdrop ;

: pseudo2 \ xsi s m -- | r -- f
  >bx bx b1- >bx false >ys 0
  do bover bover i blshift 
     by b**mod bx b=
     if true ys! leave 
     then
  loop xdrop xdrop bdrop bdrop ys> ;

: miller \ u -- | -- f		u odd >2
  >bx bx xsi bx rs >zs bover bover
  bx pseudo1 ?dup
  if xdrop bdrop bdrop zsdrop exit
  then bx> zs> pseudo2 ;
\ u is of the form u=1+s*2^r, where s is odd
\ given any number 1 =< xsi < u
\ if xsi^s=1[mod u] or
\ if it exist j: 0 =< j < r with
\ xsi^[s*2^j]=-1[mod u]
\ then u is pseudoprime.

: next_miller b1or \ u -- v
  begin bdup miller 0= 
  while b2+ 
  repeat ;

\ prime number testing

: fermat \ u -- | -- f			fermat prime test
  len1 cell =
  if btwo 
  else 0FF random 3 or s>b
  then bover bone b- brot b**mod
  1 digit= bdrop ;

: prime~ \ n -- f		
  dup 3 = if drop true exit then
  >xs true >ys xs@ s>b bsqrtf b>s 1+ 3
  ?do xs@ i umod 0=
    if false ys! leave 
    then 2
  +loop xsdrop ys> ;

: p012 \ n -- f
  case 0 of false endof
       1 of false endof
       2 of true endof
  endcase ;

: prime \ n -- f
  dup 3 u< if p012 exit then
  dup 1 and 0= if drop false exit then
  prime~ ;

: bprime \ u -- | -- f
  len1 cell = if b>s prime exit then
  beven if bdrop false exit then
  bdup fermat
  if bdup miller
     if miller 
     else bdrop false 
     then
  else bdrop false
  then ;

: bnext_prime \ m -- p 
  b1or 
  begin bdup bprime 0=
  while b2+
  repeat ;

\ sqrt sieve

: sieve9  \ v -- v | -- f   \ true=stuck in sieve
  bdup 9 bs/mod bdrop
  case 0 of false endof
       1 of false endof
       4 of false endof
       7 of false endof
     dup of true  endof
  endcase ;

: sieve16 \ v -- v | -- f
  first @ 0F and
  case 	0 of false endof
	1 of false endof
	4 of false endof
	9 of false endof
      	dup of  true endof
  endcase ;

: sieve2 \ v -- v | -- f
  bdup 0 >xs
  begin first @ 1 and 0=
  while b2/ 1 xs+!
  repeat xs> 1 and
  if bdrop true exit
  then bdrop false ;

: sieve \ v -- v | -- f
  sieve16 if true exit then
  sieve9  if true exit then
  sieve2  if true exit then
  false ;

: notsqrt? \ v -- v | -- f
  br0= if false exit then
  sieve
  ?dup if exit then
  bdup bsqrtx xdrop bdup b* br= bdrop 0= ;

\ hart factoring - "one line factoring"
: bhart \ w -- v
  0 >xs >bx 
  begin 1 xs+! bx xs@ bs* bsqrtc bdup
     bdup b* bx bmod notsqrt? 0=
     if bsqrtf |b-| bx> bgcd xsdrop exit 
     then bdrop bdrop
  again ;
\ http://programmingpraxis.com/2014/01/28/harts-one-line-factoring-algorithm/

\ testing for single number divisors of w in the intervall n,m-1
: sfac \ w -- w ?v | m n -- f 
  beven 
  if 2drop 2 bdup b2/ exit 
  then 0 >xs 
  do bdup i bs/mod 0= 
     if i xs! leave 
     then bdrop 2
  +loop xs> ;

\ cl b 10 b 29 b** b 5342347 b+ bnext_prime b 10 b 31 b** b 2232788 b+ bnext_prime .b b* bhart .b

-1 value slim

: bhart+ \ w -- v
  btwo br< bdrop 
  if exit 
  then bdup bprime 
  if bdrop bone exit 
  then slim 3 sfac ?dup 
  if bdrop bdrop s>b exit 
  then bhart ;

: bfac \ w -- v1...vn
  bdup bhart+ 
  bone br= bdrop 
  if bdrop exit
  then btuck b/ recurse ;
  
: bfac# \ w -- v1...vn | -- n
  bdepth 1- bfac bdepth swap - ;

\ calculating inverse modulo for unsigned integers

: sign-comp  \ t q t' -- t" | f" f f' -- fnew f'
  b* >r r@ xor 2* +
  case 0 of b~ endof
      -1 of b+ true endof
      -2 of b+ false endof
      -3 of b~ 0= endof
  endcase r> ;

variable flag
variable flag11
variable flag12
variable flag21
variable flag22

: binvmod \ u v -- u' 
  false flag !
  false flag11 ! false flag12 !
  false flag21 ! false flag22 !
  btuck bzero bone b2swap bswap
  begin br0= 0=
  while bover bover b/ >bx 
     flag21 @ flag22 @ xor flag !
     b2swap btuck bx flag12 @ flag @ flag11 @
     sign-comp flag12 ! flag11 !
     b2swap btuck bx> 
     flag22 @ flag @ flag21 @
     sign-comp flag22 ! flag21 !
  repeat bdrop bdrop bdrop flag12 @
  if bover |b-| 
  then bswap bmod ; 

base !
